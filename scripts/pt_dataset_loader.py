"""
pt_dataset_loader.py
Utility to load the .pt dataset produced by convert_trajectories_to_pt.py
and prepare the data arrays needed to train/evaluate the HumanGazeNet
gaze predictor defined in gaze_predictor.py.

Typical usage
-------------
from scripts.pt_dataset_loader import load_gaze_predictor_data

imgs_nhwc, gaze_masks, valid_indices = load_gaze_predictor_data(
    pt_path='data/seaquest/full_data_28_episodes_10p0_sigma_win_10_obj_49.pt',
    frame_stack=4,
)
"""

import numpy as np
import torch


def load_gaze_predictor_data(
    pt_path: str,
    frame_stack: int = 4,
    normalize_obs: bool = True,
    device: str = "cpu",
):
    """
    Load a .pt dataset file and return arrays compatible with
    ``Human_Gaze_Predictor.train_model``.

    Parameters
    ----------
    pt_path : str
        Path to the .pt file generated by convert_trajectories_to_pt.py.
    frame_stack : int
        Number of consecutive frames to stack as one input sample (default: 4).
        Must match ``HumanGazeNet(in_channels=frame_stack)``.
    normalize_obs : bool
        If True, divide observations from uint8 [0, 255] to float32 [0, 1].
    device : str
        Torch device to load tensors onto (``"cpu"`` or ``"cuda"``).

    Returns
    -------
    imgs_nhwc : np.ndarray  shape (N, H, W, frame_stack)
        Frame-stacked grayscale observations in NHWC format.
        N = total frames - (frame_stack - 1), so each entry contains
        [t-k+1, â€¦, t] frames for the t-th step.
    gaze_masks : torch.Tensor  shape (total_frames, H, W)
        Full gaze heatmap tensor from the dataset (ground truth).
    valid_indices : torch.Tensor  shape (N,)
        Maps each entry of imgs_nhwc to its corresponding row in gaze_masks.
        Pass this directly to ``train_model``.
    """
    print(f"Loading dataset from {pt_path} ...")
    data = torch.load(pt_path, map_location=device, weights_only=False)

    obs        = data["observations"]   # (T, H, W) uint8
    gaze_masks = data["gaze_image"]     # (T, H, W) float32

    T, H, W = obs.shape
    print(f"  Total frames: {T}  |  Frame size: {H}x{W}  |  Frame stack: {frame_stack}")

    # Convert observations to float32 (obs is a numpy array)
    obs_f32 = obs.astype(np.float32)
    if normalize_obs:
        obs_f32 /= 255.0

    # Convert gaze_masks to tensor if it isn't already
    if not isinstance(gaze_masks, torch.Tensor):
        gaze_masks = torch.from_numpy(gaze_masks)

    # Build frame-stacked windows: shape (N, H, W, frame_stack)
    valid_start = frame_stack - 1          # first index that has a full stack
    N = T - valid_start

    # Preallocate
    imgs_nhwc = np.zeros((N, H, W, frame_stack), dtype=np.float32)
    valid_indices = torch.arange(valid_start, T, dtype=torch.long)  # maps to gaze_masks

    for i in range(N):
        t = i + valid_start
        for k in range(frame_stack):
            imgs_nhwc[i, :, :, k] = obs_f32[t - (frame_stack - 1 - k)]

    print(f"  imgs_nhwc shape : {imgs_nhwc.shape}")
    print(f"  gaze_masks shape: {tuple(gaze_masks.shape)}")
    print(f"  valid_indices   : [{valid_indices[0]}..{valid_indices[-1]}] ({len(valid_indices)} entries)")
    return imgs_nhwc, gaze_masks, valid_indices


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Test the pt dataset loader.")
    parser.add_argument("--dataset", "-d", type=str, required=True, help="Path to .pt dataset file.")
    parser.add_argument("--frame_stack", type=int, default=4)
    args = parser.parse_args()

    imgs, masks, idxs = load_gaze_predictor_data(args.dataset, frame_stack=args.frame_stack)
    print("\nSanity check:")
    print(f"  imgs dtype   : {imgs.dtype}  range=[{imgs.min():.3f}, {imgs.max():.3f}]")
    print(f"  masks dtype  : {masks.dtype}  range=[{masks.min():.3f}, {masks.max():.3f}]")
    print(f"  idxs sample  : {idxs[:5].tolist()}")
